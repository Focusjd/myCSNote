操作系统

## Linux 系统调用：

| Task     | Commands                    |
| -------- | --------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown()   |

Chmod:

- `r`：4
- `w`：2
- `x`：1

```
chmod 755 filename
```

7(即4+2+1)表示所有者的权限（读、写、执行），5表示组的权限（读和执行），5表示其他人的权限（读和执行）



## 进程管理

进程是资源分配的基本单位。

线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。

例如：浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

### 区别

Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

### 进程调度算法

#### 批处理系统

**1.1 先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

**1.2 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

#### 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

**2.1 时间片轮转**

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

**2.2 优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**2.3 多级反馈队列**

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

#### 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

### 进程状态

五个：

* created

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源
- terminated



只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。

阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

![Screenshot 2023-11-02 at 5.00.42 PM](/Users/dianjiao/Library/Application Support/typora-user-images/Screenshot 2023-11-02 at 5.00.42 PM.png)

### 进程同步

1. **临界区**：临界区是一个程序段，其中的指令访问共享资源，并且在任何时刻只允许一个进程进入和执行。
2. **互斥**：这是一个基本的同步概念，确保任何时刻只有一个进程可以进入其临界区。
3. **同步原语**：这是操作系统提供的一组用于支持进程同步的低级命令。以下是一些常见的同步原语：
   - **信号量（Semaphore）**：是一个整数值，可以进行上锁和解锁操作。它支持两种操作：`wait()` 和 `signal()`，通常用于实现互斥和同步。
   - **互斥锁（Mutex）**：特定于互斥的同步原语，保证同一时刻只有一个进程或线程可以执行特定的代码段。
   - **条件变量**：与互斥锁一起使用，允许进程在满足某些条件之前等待。
4. **死锁**：这是当两个或多个进程无限期地等待一组资源，而这组资源已被这些进程中的其他进程占用时发生的情况。解决死锁的方法包括预防、避免、检测和恢复。
5. **饥饿**：这是一个进程无法获得所需资源的情况，因此它无法进展，而其他进程可能重复地获得资源。
6. **生产者-消费者问题**：这是一个经典的进程同步问题，其中有一个或多个生产者进程生成数据并放入缓冲区，一个或多个消费者进程从缓冲区中取出并消费数据。目标是确保生产者不会在缓冲区满时加入数据，消费者不会在缓冲区空时尝试获取数据。（**实际的例子：一个打印机队列，有多个打印机。）**

1. **读者-写者问题**：另一个经典的同步问题，涉及到多个读者进程和多个写者进程。读者进程只读取数据，写者进程修改数据。挑战在于允许多个读者同时访问数据，但只允许一个写者（无读者时）访问数据。

### 进程通信

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

方法：

1. **管道 (Pipe)**:
   - 最古老的IPC形式之一。
   - 提供一个单向（半双工）通信通道，通常在父子进程间使用。
   - 数据写入管道的一端可以从另一端读出。
2. **命名管道 (Named Pipe 或 FIFO)**:
   - 类似于管道，但它们在文件系统上有一个名称，所以不相关的进程也可以通信。
3. **消息队列 (Message Queues)**:
   - 允许进程发送和接收消息。
   - 消息被放入一个队列中，可以按顺序读取。
   - 每条消息都有一个类型，使得接收方可以选择性地接收某种类型的消息。
4. **共享内存 (Shared Memory)**:
   - 允许多个进程直接访问同一块内存区域。
   - 是最快的IPC方法，因为数据不需要在进程之间复制。
   - 通常与其他同步机制一起使用（例如信号量），以确保多个进程正确地访问共享数据。
5. **套接字 (Sockets)**:
   - 提供了两台计算机之间的双向通信机制。
   - 可用于本地进程间通信或网络通信。
   - 支持多种通信协议，如TCP/IP、UDP等。
6. **信号 (Signals)**:
   - 提供了一种向进程发送通知的方式。
   - 通常用于异步事件，如进程终止、闹钟信号等。
7. **信号量 (Semaphores)**:
   - 主要用于同步，但也可以用于进程间通信。
   - 通常与共享内存结合使用。
8. **共享文件**:
   - 进程可以通过在文件系统上读写同一个文件来交换数据。
9. **套接字对 (Socket Pairs)**:
   - 与套接字类似，但专门用于同一台机器上的进程间通信。
10. **远程过程调用 (Remote Procedure Call, RPC)**:
    - 允许程序调用另一台机器上的过程或函数，就像它是本地的一样。

## 死锁

**必要条件**

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。



**死锁预防**
在程序运行之前预防发生死锁。

1. 破坏互斥条件
例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

2. 破坏占有和等待条件
一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

3. 破坏不可抢占条件
4. 破坏环路等待
给资源统一编号，进程只能按编号顺序来请求资源。

**死锁避免**
在程序运行时避免发生死锁。

银行家算法



