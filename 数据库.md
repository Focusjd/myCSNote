# MySQL





[TOC]



## 索引

索引是帮助MySQL高效获取数据的排好序的数据结构，它提前按照一定的规则进行排序和组织，能够帮助快速定位记录。

### 索引数据结构

#### B+树：

B+树是B树的变种。在B+树中，所有的数据都存储在叶子节点中，并且叶子节点之间是相互链接的。（内部节点只存储键值，而不包含实际数据。）

**与B树的对比：**

- **数据存储**：B树的数据存储在整个树中，而B+树的数据只存储在叶子节点。
- **树高**：B+树的树高通常低于B树，因为内部节点不存储数据。
- **范围查询**：B+树由于其叶子节点的链表结构，更适合于范围查询。
- **磁盘读写**：B+树由于更低的树高和有序的叶子节点，更适合于磁盘读写操作。



Mysql**索引使用不使用二叉树而使用B+树的原因**

在处理自增数据时，存放在二叉树中对索引效率提升没有帮助

- **磁盘 I/O 最小化**：
  - B+树是一种多路平衡搜索树，相比于二叉树，它有更低的树高，可以减少磁盘读写次数。在数据库操作中，磁盘 I/O 通常是性能瓶颈，因此减少读取次数对于提高查询效率至关重要。
- **更好的数据局部性**：
  - B+树的节点存储多个键值，这意味着它们可以利用磁盘块的空间，提高数据的局部性。数据局部性的提高可以减少磁盘寻道时间和读取时间。
- **高效的范围查询**：
  - B+树的所有数据指针都存在叶子节点，并且叶子节点之间是相互链接的。这使得对于范围查询，B+树比二叉树更高效，因为它可以通过遍历叶子节点的链表来顺序访问所有在范围内的数据。
- **插入和删除操作的优化**：
  - 在 B+树中，插入和删除操作通常更加高效，因为它们只需要对树进行局部调整。与之相比，二叉搜索树可能需要更频繁的平衡操作（例如，在 AVL 树或红黑树中）。
- **节省空间**：
  - 由于 B+树的分支节点不存储数据，只存储键和子节点的指针，因此可以有更多的分支，从而使树的高度更低。这在存储大量数据时节省了空间。



##### MyISAM存储引擎

- 早期的默认存储引擎，适用于 MySQL 5.5.5 之前的版本。
- **不支持事务和行级锁定**，但提供全文搜索功能。
- 适合于读密集型的应用，如博客、CMS 系统等。

##### **MyISAM**索引实现（非聚集索引）

索引文件和数据文件分离（非聚集索引）



##### InnoDB存储引擎

- 是 MySQL 的默认存储引擎（自 MySQL 5.5.5 版本开始）。
- 支持事务处理，具备 ACID（原子性、一致性、隔离性、持久性）属性。
- 提供行级锁定和外键约束支持。
- 适合处理大量数据的情况，优秀的崩溃恢复能力。

##### InnoDB索引实现（默认为主键创建聚集索引）

+ 表数据按照B+Tree组织一个索引结构文件
+ 聚集索引-叶子结点包含完整记录
+ InnoDB建议必须建立主键，推荐使用**整形自增**主键：整形方便比较，自增因为要求有顺序每个节点有存储上限，自增的索引可以减少平衡次数
+ InnoDB二级索引，所谓非主键索引都可以称为二级索引，**二级索引是非聚集索引**，需要回表





#### 哈希索引（不常用因为无法范围查找）

Memory引擎支持

1. ##### **快速查找**：

   - 哈希索引可以提供非常快的数据访问速度，尤其是对于等值查询（如 `WHERE key = value`）。

2. **不适合范围查询**：

   - 哈希索引不适用于范围查询（如 `WHERE key > value`）。这是因为哈希函数的输出不保留键的顺序。

3. **处理哈希冲突**：

   - 如果两个不同的键产生相同的哈希值（即哈希冲突），则需要有机制来处理这种情况，通常是通过链表或开放寻址。

4. **内存使用**：

   - 哈希索引通常存储在内存中，这意味着它们可以提供快速的访问速度。但这也意味着它们可能受限于内存大小。

##### 使用场景

- **适合场景**：

  - 适合于高速查找和频繁更新的场景。
  - 适用于需要快速查找特定键值的应用，如缓存系统。

- **不适合场景**：

  - 不适合于需要进行范围查询的场景。
  - 对于具有大量重复键值的数据不太有效。

  

#### Full-text索引

全文索引（Full-text Index）是数据库中用于提升全文搜索效率的一种特殊类型的索引。它主要用于搜索文本中的关键词，而不是比较文本整体的相等性。这种索引适用于寻找包含某些词（单词或短语）的文档或记录，特别适用于大量文本数据的搜索，如文章、邮件内容、产品描述等。





### 复合（联合）索引的结构

假设有一个复合索引包含三个列：`(A, B, C)`。这个索引可以被视为按照列 A、列 B 和列 C 排序的数据列表。

##### 最左前缀原则的含义

1. **索引的使用**：
   - 如果查询条件包含了索引的最左边的列（即列 A），则优化器可以利用该索引。
   - 如果查询条件不包括最左边的列（只包括 B 或 C），则无法充分利用这个索引。
2. **部分使用索引**：
   - 如果查询条件包括列 A 和列 B，索引将非常有效。
   - 如果查询条件只包括列 A，索引仍然有用，但不如同时包含 A 和 B 那么有效。
3. **顺序重要**：
   - 查询条件中涉及的列的顺序应该与索引中列的顺序一致。例如，针对 `(A, B, C)` 的索引，条件应该是基于 A 或 A 和 B，或 A、B 和 C 的顺序。

##### 例子

假设有一个表 `users`，其上有一个复合索引 `(first_name, last_name, age)`。以下是一些查询例子，说明最左前缀原则的应用：

- `SELECT * FROM users WHERE first_name = 'John'`：
  - 这个查询可以充分利用索引。
- `SELECT * FROM users WHERE first_name = 'John' AND last_name = 'Doe'`：
  - 这个查询可以更有效地利用索引，因为它使用了索引的前两列。
- `SELECT * FROM users WHERE last_name = 'Doe'`：
  - 这个查询无法利用索引，因为它没有使用索引的最左列。
- `SELECT * FROM users WHERE first_name = 'John' AND age = 30`：
  - 这个查询只能部分利用索引（仅针对 `first_name`），因为 `age` 不是紧随 `first_name` 的列。



### 索引覆盖

需要查询的字段都在索引列当中，不需要回表等，就是覆盖查询



### 索引的使用和优缺点

优点：

+ 提高检索效率
+ 降低排序成本，索引对应字段有自动排序的功能

缺点：

+ 创建和维护索引耗费时间，数据越多耗费的时间越多
+ 索引占用的物理空间随着数据量增大而增大
+ 降低表的增删改效率，需要动态维护



### 索引失效

order by 或者 范围查找失效，查询优化器认为回表代价太大，不如直接全表扫描

1. **使用非索引列作为查询条件**: 当查询条件不涉及索引列时，索引无法被使用。
2. **在索引列上使用函数或表达式**: 如`SELECT * FROM table WHERE YEAR(date_column) = 2021;`。这里，即使`date_column`上有索引，使用`YEAR()`函数也会导致索引失效。
3. **隐式类型转换**: 当查询条件中的数据类型与索引列的类型不一致时，可能会导致索引失效。例如，如果索引列是字符串类型，但查询条件使用数字进行比较，索引可能不会被使用。**因为索引使用字符串构建的，需要转换索引到字符串才能进行查找代价太大**
4. **使用`LIKE`操作符以通配符开头**: 如`SELECT * FROM table WHERE column LIKE '%value%';`。如果模式以通配符开头，索引将不会被使用。
5. **使用`OR`条件连接不同列**: 如果使用`OR`连接不同的列，且这些列分别有不同的索引，那么索引可能不会被有效使用。
6. **索引列参与计算或运算**: 如果在索引列上进行计算或运算，如`SELECT * FROM table WHERE column + 1 = value;`，这通常会导致索引失效。
7. **范围查询之后的列**: 在复合索引的情况下，如果对第一个索引列进行范围查询（如`>`、`<`、`BETWEEN`、`LIKE`等），那么该列之后的索引列将不被利用。
8. **返回大量数据的查询**: 如果查询**返回表中大部分的行，查询优化器可能决定全表扫描比使用索引更有效**。
9. **不匹配的字符集和校对规则**: 如果查询的字符集或校对规则与索引列的不一致，可能导致索引失效。
10. **NULL值的处理**: 在某些情况下，包含NULL值的列可能不会有效地使用索引。



## 事务

### ACID

数据库事务是一系列操作，这些操作要么全部成功执行，要么全部不执行。事务是数据库管理系统中的一个关键概念，用于确保数据的完整性和一致性。事务具有以下四个主要特性，通常被称为ACID特性：

1. **原子性（Atomicity）**：事务中的所有操作要么全部完成，要么全部不完成。如果事务中的某个操作失败，整个事务将回滚到事务开始前的状态。**原子性由undo log保证**
2. **一致性（Consistency）**：事务必须保证数据库从一个一致的状态转移到另一个一致的状态。这意味着事务的执行结果必须符合所有数据库规则，包括数据完整性约束。**由其他三个性质保证**和业务逻辑保证
3. **隔离性（Isolation）**：事务的执行不应该被其他事务干扰。多个并发事务之间的操作应该是相互隔离的，以防止数据不一致。**由MVCC保证**
4. **持久性（Durability）**：一旦事务完成，它对数据库的更改是永久性的，即使系统发生故障也不会丢失。**持久性由redo log保证**可以从redo log恢复，redo log刷盘在空闲时进行



##### Undo Log

- **Undo log** 用于记录事务执行前的数据状态。这使得数据库可以在事务失败或需要回滚时恢复旧数据。
- 它通常存储在硬盘上，以确保即使在数据库崩溃的情况下也能够执行事务回滚。

##### Redo Log

- **Redo log** 记录了事务所做的修改，以便在数据库崩溃后重新应用这些修改，确保事务的持久性。
- 这些日志同样存储在硬盘上，因为它们必须在系统恢复后仍然可用。

### 事务隔离级别

MySQL支持以下四种事务隔离级别，每个级别在提供数据一致性和并发性能之间做出不同的平衡。隔离级别从低到高排列如下：

1. **读未提交（Read Uncommitted）**:
   - 这是最低的隔离级别。
   - 在此级别，事务可以读取尚未提交的其他事务所做的更改。
   - 这可能导致“脏读”，即一个事务可能读取到另一个事务未提交的数据，如果那个事务失败并回滚，读取的数据就是无效的。
2. **读已提交（Read Committed）**:
   - 在此级别，事务只能读取已经提交的更改。
   - 这避免了脏读，但仍然可能出现“**不可重复读**”，即在同一事务中，两次读取同一数据可能得到不同的结果，因为在两次读取之间，另一个事务可能修改了数据并提交。
3. **可重复读（Repeatable Read）**:
   - 这是MySQL的默认隔离级别。**MVCC，通过undo log实现，绑定第一次查询的数据**
   - 在此级别，事务保证在整个事务期间可以多次读取同一数据并获得相同的结果，即使其他事务在此期间提交了更改。
   - 这避免了不可重复读，但可能导致“**幻读**”，即当一个事务在读取某个范围的记录时，另一个事务插入了新记录，当再次读取时就会看到新的“幻影”记录。
4. **串行化（Serializable）**:
   - 这是最高的隔离级别。
   - 它完全串行化处理事务，以确保事务之间不会相互影响。
   - 这避免了幻读，但可能会导致大量的锁和降低数据库的并发性能。

即使是最低级别的隔离（如读未提交，Read Uncommitted）也通常会阻止脏写





### MVCC

**MVCC 读的是历史数据，写的是现实数据**

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现**提交读**和**可重复读**这两种隔离级别。其他两个和MVCC不兼容。未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

#### 基本思想

在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。

**在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。**

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

#### MVCC的工作原理

1. **数据版本化**:
   - 在MVCC中，每次数据被修改时，系统不会直接覆盖旧数据，而是创建数据的新版本。这意味着同一数据可以存在多个版本。
2. **事务快照**:
   - 当一个事务开始时，它会获得一个数据库的快照。这个快照基于数据的版本生成，反映了事务开始时数据库的状态。
3. **非阻塞读取**:
   - 事务可以读取快照中的数据而不会被其他事务的写操作阻塞，因为写操作会生成数据的新版本，而不是直接修改当前版本。
4. **版本控制**:
   - 系统会维护每个数据版本的有效时间或事务ID范围。事务只能看到在其快照时间范围内有效的数据版本。

#### MVCC的优点

1. **提高并发性能**:
   - MVCC允许读取操作和写入操作在不同版本的数据上同时进行，从而减少了锁的需要，提高了并发性能。
2. **减少锁争用**:
   - 因为读取操作通常不需要锁定资源，所以减少了锁争用的可能性。
3. **防止幻读**:
   - 在某些隔离级别下，MVCC可以防止幻读，因为事务只能看到其快照中的数据。
4. **支持乐观并发控制**:
   - MVCC是实现乐观并发控制的基础，它假设多个事务通常不会冲突，只在提交时检测数据冲突。

#### 版本号

- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。

#### Undo 日志

MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。



### 锁

MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。但可以强制指定进行加锁操作。

MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。