# MySQL





[TOC]



## 索引

索引是帮助MySQL高效获取数据的排好序的数据结构，它提前按照一定的规则进行排序和组织，能够帮助快速定位记录。

### 索引数据结构

#### B+树：

B+树是B树的变种。在B+树中，所有的数据都存储在叶子节点中，并且叶子节点之间是相互链接的。（内部节点只存储键值，而不包含实际数据。）

**与B树的对比：**

- **数据存储**：B树的数据存储在整个树中，而B+树的数据只存储在叶子节点。
- **树高**：B+树的树高通常低于B树，因为内部节点不存储数据。
- **范围查询**：B+树由于其叶子节点的链表结构，更适合于范围查询。
- **磁盘读写**：B+树由于更低的树高和有序的叶子节点，更适合于磁盘读写操作。



Mysql**索引使用不使用二叉树而使用B+树的原因**

在处理自增数据时，存放在二叉树中对索引效率提升没有帮助

- **磁盘 I/O 最小化**：
  - B+树是一种多路平衡搜索树，相比于二叉树，它有更低的树高，可以减少磁盘读写次数。在数据库操作中，磁盘 I/O 通常是性能瓶颈，因此减少读取次数对于提高查询效率至关重要。
- **更好的数据局部性**：
  - B+树的节点存储多个键值，这意味着它们可以利用磁盘块的空间，提高数据的局部性。数据局部性的提高可以减少磁盘寻道时间和读取时间。
- **高效的范围查询**：
  - B+树的所有数据指针都存在叶子节点，并且叶子节点之间是相互链接的。这使得对于范围查询，B+树比二叉树更高效，因为它可以通过遍历叶子节点的链表来顺序访问所有在范围内的数据。
- **插入和删除操作的优化**：
  - 在 B+树中，插入和删除操作通常更加高效，因为它们只需要对树进行局部调整。与之相比，二叉搜索树可能需要更频繁的平衡操作（例如，在 AVL 树或红黑树中）。
- **节省空间**：
  - 由于 B+树的分支节点不存储数据，只存储键和子节点的指针，因此可以有更多的分支，从而使树的高度更低。这在存储大量数据时节省了空间。



##### MyISAM存储引擎

- 早期的默认存储引擎，适用于 MySQL 5.5.5 之前的版本。
- 不支持事务和行级锁定，但提供全文搜索功能。
- 适合于读密集型的应用，如博客、CMS 系统等。

##### **MyISAM**索引实现（非聚集索引）

索引文件和数据文件分离（非聚集索引）



##### InnoDB存储引擎

- 是 MySQL 的默认存储引擎（自 MySQL 5.5.5 版本开始）。
- 支持事务处理，具备 ACID（原子性、一致性、隔离性、持久性）属性。
- 提供行级锁定和外键约束支持。
- 适合处理大量数据的情况，优秀的崩溃恢复能力。

##### InnoDB索引实现（默认为主键创建聚集索引）

+ 表数据按照B+Tree组织一个索引结构文件
+ 聚集索引-叶子结点包含完整记录
+ InnoDB建议必须建立主键，推荐使用**整形自增**主键：整形方便比较，自增因为要求有顺序每个节点有存储上限，自增的索引可以减少平衡次数
+ InnoDB二级索引，所谓非主键索引都可以称为二级索引，**二级索引是非聚集索引**，需要回表





#### 哈希索引（不常用因为无法范围查找）

Memory引擎支持

1. ##### **快速查找**：

   - 哈希索引可以提供非常快的数据访问速度，尤其是对于等值查询（如 `WHERE key = value`）。

2. **不适合范围查询**：

   - 哈希索引不适用于范围查询（如 `WHERE key > value`）。这是因为哈希函数的输出不保留键的顺序。

3. **处理哈希冲突**：

   - 如果两个不同的键产生相同的哈希值（即哈希冲突），则需要有机制来处理这种情况，通常是通过链表或开放寻址。

4. **内存使用**：

   - 哈希索引通常存储在内存中，这意味着它们可以提供快速的访问速度。但这也意味着它们可能受限于内存大小。

##### 使用场景

- **适合场景**：

  - 适合于高速查找和频繁更新的场景。
  - 适用于需要快速查找特定键值的应用，如缓存系统。

- **不适合场景**：

  - 不适合于需要进行范围查询的场景。
  - 对于具有大量重复键值的数据不太有效。

  

#### Full-text索引

全文索引（Full-text Index）是数据库中用于提升全文搜索效率的一种特殊类型的索引。它主要用于搜索文本中的关键词，而不是比较文本整体的相等性。这种索引适用于寻找包含某些词（单词或短语）的文档或记录，特别适用于大量文本数据的搜索，如文章、邮件内容、产品描述等。





### 复合（联合）索引的结构

假设有一个复合索引包含三个列：`(A, B, C)`。这个索引可以被视为按照列 A、列 B 和列 C 排序的数据列表。

##### 最左前缀原则的含义

1. **索引的使用**：
   - 如果查询条件包含了索引的最左边的列（即列 A），则优化器可以利用该索引。
   - 如果查询条件不包括最左边的列（只包括 B 或 C），则无法充分利用这个索引。
2. **部分使用索引**：
   - 如果查询条件包括列 A 和列 B，索引将非常有效。
   - 如果查询条件只包括列 A，索引仍然有用，但不如同时包含 A 和 B 那么有效。
3. **顺序重要**：
   - 查询条件中涉及的列的顺序应该与索引中列的顺序一致。例如，针对 `(A, B, C)` 的索引，条件应该是基于 A 或 A 和 B，或 A、B 和 C 的顺序。

##### 例子

假设有一个表 `users`，其上有一个复合索引 `(first_name, last_name, age)`。以下是一些查询例子，说明最左前缀原则的应用：

- `SELECT * FROM users WHERE first_name = 'John'`：
  - 这个查询可以充分利用索引。
- `SELECT * FROM users WHERE first_name = 'John' AND last_name = 'Doe'`：
  - 这个查询可以更有效地利用索引，因为它使用了索引的前两列。
- `SELECT * FROM users WHERE last_name = 'Doe'`：
  - 这个查询无法利用索引，因为它没有使用索引的最左列。
- `SELECT * FROM users WHERE first_name = 'John' AND age = 30`：
  - 这个查询只能部分利用索引（仅针对 `first_name`），因为 `age` 不是紧随 `first_name` 的列。



### 索引覆盖

需要查询的字段都在索引烈当中，不需要回表等，就是覆盖查询



### 索引的使用和优缺点

优点：

+ 提高检索效率
+ 降低排序成本，索引对应字段有自动排序的功能

缺点：

+ 创建和维护索引耗费时间，数据越多耗费的时间越多
+ 索引占用的物理空间随着数据量增大而增大
+ 降低表的增删改效率，需要动态维护