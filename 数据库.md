# MySQL





[TOC]



## 索引

索引是帮助MySQL高效获取数据的排好序的数据结构，它提前按照一定的规则进行排序和组织，能够帮助快速定位记录。

### 索引数据结构

#### B+树：

B+树是B树的变种。在B+树中，所有的数据都存储在叶子节点中，并且叶子节点之间是相互链接的。（内部节点只存储键值，而不包含实际数据。）

**与B树的对比：**

- **数据存储**：B树的数据存储在整个树中，而B+树的数据只存储在叶子节点。
- **树高**：B+树的树高通常低于B树，因为内部节点不存储数据。
- **范围查询**：B+树由于其叶子节点的链表结构，更适合于范围查询。
- **磁盘读写**：B+树由于更低的树高和有序的叶子节点，更适合于磁盘读写操作。



Mysql**索引使用不使用二叉树而使用B+树的原因**

在处理自增数据时，存放在二叉树中对索引效率提升没有帮助

- **磁盘 I/O 最小化**：
  - B+树是一种多路平衡搜索树，相比于二叉树，它有更低的树高，可以减少磁盘读写次数。在数据库操作中，磁盘 I/O 通常是性能瓶颈，因此减少读取次数对于提高查询效率至关重要。
- **更好的数据局部性**：
  - B+树的节点存储多个键值，这意味着它们可以利用磁盘块的空间，提高数据的局部性。数据局部性的提高可以减少磁盘寻道时间和读取时间。
- **高效的范围查询**：
  - B+树的所有数据指针都存在叶子节点，并且叶子节点之间是相互链接的。这使得对于范围查询，B+树比二叉树更高效，因为它可以通过遍历叶子节点的链表来顺序访问所有在范围内的数据。
- **插入和删除操作的优化**：
  - 在 B+树中，插入和删除操作通常更加高效，因为它们只需要对树进行局部调整。与之相比，二叉搜索树可能需要更频繁的平衡操作（例如，在 AVL 树或红黑树中）。
- **节省空间**：
  - 由于 B+树的分支节点不存储数据，只存储键和子节点的指针，因此可以有更多的分支，从而使树的高度更低。这在存储大量数据时节省了空间。



##### MyISAM存储引擎

- 早期的默认存储引擎，适用于 MySQL 5.5.5 之前的版本。
- **不支持事务和行级锁定**，但提供全文搜索功能。
- 适合于读密集型的应用，如博客、CMS 系统等。

##### **MyISAM**索引实现（非聚集索引）

索引文件和数据文件分离（非聚集索引）



##### InnoDB存储引擎

- 是 MySQL 的默认存储引擎（自 MySQL 5.5.5 版本开始）。
- 支持事务处理，具备 ACID（原子性、一致性、隔离性、持久性）属性。
- 提供行级锁定和外键约束支持。
- 适合处理大量数据的情况，优秀的崩溃恢复能力。

##### InnoDB索引实现（默认为主键创建聚集索引）

+ 表数据按照B+Tree组织一个索引结构文件
+ 聚集索引-叶子结点包含完整记录
+ InnoDB建议必须建立主键，推荐使用**整形自增**主键：整形方便比较，自增因为要求有顺序每个节点有存储上限，自增的索引可以减少平衡次数
+ InnoDB二级索引，所谓非主键索引都可以称为二级索引，**二级索引是非聚集索引**，需要回表





#### 哈希索引（不常用因为无法范围查找）

Memory引擎支持

1. ##### **快速查找**：

   - 哈希索引可以提供非常快的数据访问速度，尤其是对于等值查询（如 `WHERE key = value`）。

2. **不适合范围查询**：

   - 哈希索引不适用于范围查询（如 `WHERE key > value`）。这是因为哈希函数的输出不保留键的顺序。

3. **处理哈希冲突**：

   - 如果两个不同的键产生相同的哈希值（即哈希冲突），则需要有机制来处理这种情况，通常是通过链表或开放寻址。

4. **内存使用**：

   - 哈希索引通常存储在内存中，这意味着它们可以提供快速的访问速度。但这也意味着它们可能受限于内存大小。

##### 使用场景

- **适合场景**：

  - 适合于高速查找和频繁更新的场景。
  - 适用于需要快速查找特定键值的应用，如缓存系统。

- **不适合场景**：

  - 不适合于需要进行范围查询的场景。
  - 对于具有大量重复键值的数据不太有效。

  

#### Full-text索引

全文索引（Full-text Index）是数据库中用于提升全文搜索效率的一种特殊类型的索引。它主要用于搜索文本中的关键词，而不是比较文本整体的相等性。这种索引适用于寻找包含某些词（单词或短语）的文档或记录，特别适用于大量文本数据的搜索，如文章、邮件内容、产品描述等。





### 复合（联合）索引的结构

假设有一个复合索引包含三个列：`(A, B, C)`。这个索引可以被视为按照列 A、列 B 和列 C 排序的数据列表。

##### 最左前缀原则的含义

1. **索引的使用**：
   - 如果查询条件包含了索引的最左边的列（即列 A），则优化器可以利用该索引。
   - 如果查询条件不包括最左边的列（只包括 B 或 C），则无法充分利用这个索引。
2. **部分使用索引**：
   - 如果查询条件包括列 A 和列 B，索引将非常有效。
   - 如果查询条件只包括列 A，索引仍然有用，但不如同时包含 A 和 B 那么有效。
3. **顺序重要**：
   - 查询条件中涉及的列的顺序应该与索引中列的顺序一致。例如，针对 `(A, B, C)` 的索引，条件应该是基于 A 或 A 和 B，或 A、B 和 C 的顺序。

##### 例子

假设有一个表 `users`，其上有一个复合索引 `(first_name, last_name, age)`。以下是一些查询例子，说明最左前缀原则的应用：

- `SELECT * FROM users WHERE first_name = 'John'`：
  - 这个查询可以充分利用索引。
- `SELECT * FROM users WHERE first_name = 'John' AND last_name = 'Doe'`：
  - 这个查询可以更有效地利用索引，因为它使用了索引的前两列。
- `SELECT * FROM users WHERE last_name = 'Doe'`：
  - 这个查询无法利用索引，因为它没有使用索引的最左列。
- `SELECT * FROM users WHERE first_name = 'John' AND age = 30`：
  - 这个查询只能部分利用索引（仅针对 `first_name`），因为 `age` 不是紧随 `first_name` 的列。



### 索引覆盖

需要查询的字段都在索引列当中，不需要回表等，就是覆盖查询



### 索引的使用和优缺点

优点：

+ 提高检索效率
+ 降低排序成本，索引对应字段有自动排序的功能

缺点：

+ 创建和维护索引耗费时间，数据越多耗费的时间越多
+ 索引占用的物理空间随着数据量增大而增大
+ 降低表的增删改效率，需要动态维护



### 索引失效

order by 或者 范围查找失效，查询优化器认为回表代价太大，不如直接全表扫描

1. **使用非索引列作为查询条件**: 当查询条件不涉及索引列时，索引无法被使用。
2. **在索引列上使用函数或表达式**: 如`SELECT * FROM table WHERE YEAR(date_column) = 2021;`。这里，即使`date_column`上有索引，使用`YEAR()`函数也会导致索引失效。
3. **隐式类型转换**: 当查询条件中的数据类型与索引列的类型不一致时，可能会导致索引失效。例如，如果索引列是字符串类型，但查询条件使用数字进行比较，索引可能不会被使用。**因为索引使用字符串构建的，需要转换索引到字符串才能进行查找代价太大**
4. **使用`LIKE`操作符以通配符开头**: 如`SELECT * FROM table WHERE column LIKE '%value%';`。如果模式以通配符开头，索引将不会被使用。
5. **使用`OR`条件连接不同列**: 如果使用`OR`连接不同的列，且这些列分别有不同的索引，那么索引可能不会被有效使用。
6. **索引列参与计算或运算**: 如果在索引列上进行计算或运算，如`SELECT * FROM table WHERE column + 1 = value;`，这通常会导致索引失效。
7. **范围查询之后的列**: 在复合索引的情况下，如果对第一个索引列进行范围查询（如`>`、`<`、`BETWEEN`、`LIKE`等），那么该列之后的索引列将不被利用。
8. **返回大量数据的查询**: 如果查询**返回表中大部分的行，查询优化器可能决定全表扫描比使用索引更有效**。
9. **不匹配的字符集和校对规则**: 如果查询的字符集或校对规则与索引列的不一致，可能导致索引失效。
10. **NULL值的处理**: 在某些情况下，包含NULL值的列可能不会有效地使用索引。



## 事务

### ACID

数据库事务是一系列操作，这些操作要么全部成功执行，要么全部不执行。事务是数据库管理系统中的一个关键概念，用于确保数据的完整性和一致性。事务具有以下四个主要特性，通常被称为ACID特性：

1. **原子性（Atomicity）**：事务中的所有操作要么全部完成，要么全部不完成。如果事务中的某个操作失败，整个事务将回滚到事务开始前的状态。**原子性由undo log保证**
2. **一致性（Consistency）**：事务必须保证数据库从一个一致的状态转移到另一个一致的状态。这意味着事务的执行结果必须符合所有数据库规则，包括数据完整性约束。
3. **隔离性（Isolation）**：事务的执行不应该被其他事务干扰。多个并发事务之间的操作应该是相互隔离的，以防止数据不一致。
4. **持久性（Durability）**：一旦事务完成，它对数据库的更改是永久性的，即使系统发生故障也不会丢失。**持久性由redo log保证**



##### Undo Log

- **Undo log** 用于记录事务执行前的数据状态。这使得数据库可以在事务失败或需要回滚时恢复旧数据。
- 它通常存储在硬盘上，以确保即使在数据库崩溃的情况下也能够执行事务回滚。

##### Redo Log

- **Redo log** 记录了事务所做的修改，以便在数据库崩溃后重新应用这些修改，确保事务的持久性。
- 这些日志同样存储在硬盘上，因为它们必须在系统恢复后仍然可用。

### 事务隔离级别

MySQL支持以下四种事务隔离级别，每个级别在提供数据一致性和并发性能之间做出不同的平衡。隔离级别从低到高排列如下：

1. **读未提交（Read Uncommitted）**:
   - 这是最低的隔离级别。
   - 在此级别，事务可以读取尚未提交的其他事务所做的更改。
   - 这可能导致“脏读”，即一个事务可能读取到另一个事务未提交的数据，如果那个事务失败并回滚，读取的数据就是无效的。
2. **读已提交（Read Committed）**:
   - 在此级别，事务只能读取已经提交的更改。
   - 这避免了脏读，但仍然可能出现“**不可重复读**”，即在同一事务中，两次读取同一数据可能得到不同的结果，因为在两次读取之间，另一个事务可能修改了数据并提交。
3. **可重复读（Repeatable Read）**:
   - 这是MySQL的默认隔离级别。**MVCC，通过undo log实现，绑定第一次查询的数据**
   - 在此级别，事务保证在整个事务期间可以多次读取同一数据并获得相同的结果，即使其他事务在此期间提交了更改。
   - 这避免了不可重复读，但可能导致“**幻读**”，即当一个事务在读取某个范围的记录时，另一个事务插入了新记录，当再次读取时就会看到新的“幻影”记录。
4. **串行化（Serializable）**:
   - 这是最高的隔离级别。
   - 它完全串行化处理事务，以确保事务之间不会相互影响。
   - 这避免了幻读，但可能会导致大量的锁和降低数据库的并发性能。

即使是最低级别的隔离（如读未提交，Read Uncommitted）也通常会阻止脏写



**MVCC 读的是历史数据，写的是现实数据**









