# JAVA Notes

### String

String 被声明为 final，因此它不可被继承。

由于字符串（`String`）的不变性（immutability），Java中的字符串行为在某些情况下看起来与基本数据类型（如`int`）相似，尤其是在赋值和参数传递的行为方面。但是，重要的是要理解它们在本质上仍然是不同的：

1. **存储方式**：
   - 基本类型（如`int`）存储的是数据值本身。
   - 引用类型（如`String`）存储的是指向对象内存地址的引用。
2. **不变性与可变性**：
   - 基本类型的值是可变的。你可以改变一个基本类型变量的值，而不会影响其他变量。
   - **`String`是不可变的。任何对字符串的修改都会产生一个新的`String`对象，而不是更改现有对象的内容。**任何看似改变字符串内容的操作(例如拼接)实际上都是创建了一个新的`String`对象，而不是修改原有对象。
3. **参数传递**：
   - 无论是基本类型还是引用类型，Java方法参数的传递都是值传递。对于基本类型，传递的是值的拷贝；对于引用类型，传递的是引用的拷贝。
   - **对于`String`，由于其不变性，即使它是引用类型，方法内对参数的修改（指向新对象）不会影响到原始引用。这种行为在某种程度上与基本类型类似，因为基本类型的值传递也不会影响原始变量。**
4. **性能差异**：
   - 基本类型通常比引用类型更高效，因为它们直接存储值，而不涉及堆内存的分配和垃圾回收。
5. **字符串池**：
   - `String`类型有一个特殊的特性，即字符串池。这是一种优化，使得相同内容的字符串字面量共享同一个实例。这种行为是基本类型没有的。

**因为不可变所以可以有：缓存池，或者string可以用作hashmap的key**

#### Java缓存池

Java的缓存池，通常指的是Java在处理某些类型的数据时，为了提高效率和减少内存使用，而采用的一种机制，这种机制允许重复使用不变的对象。最常见的例子是整数和字符串的缓存池。

1. **字符串常量池（String Pool）**：

   - 当创建字符串时，Java首先检查字符串常量池中是否已存在相同内容的字符串。
   - 如果存在，Java会返回对该字符串的引用，而不是创建一个新对象。
   - 这种方法可以减少内存消耗，并提高性能。
   - 字符串常量池位于Java堆内存中。

2. **整数缓存池（Integer Cache）**：

   **在Java中，`Integer`缓存池的概念仅适用于`Integer`对象，而不适用于基本数据类型`int`。**

   - Java对-128到127之间的整数进行了缓存（这个范围可以通过JVM设置进行调整）。
   - 当创建这个范围内的整数对象时，会从缓存池中获取，而不是每次都创建新的对象。
   - 这样做主要是因为这个范围内的整数使用非常频繁，使用缓存可以提高效率。

3. **除了Float 和Double 之外，其他六个包装器类（Byte、Short、Integer、Long、Character、Boolean）都有常量缓存池**

每次你声明一个新的`int`变量或者给变量赋值，它都会在内存中占用一个新的位置，存储其数值。这是因为`int`是一个基本数据类型，不是对象

### Java的类型提升规则

当表达式中涉及多种不同的数据类型时，**较小的数据类型会被提升到较大的数据类型**，以保持数据的准确性和**避免数据丢失**。例如: ```cha+int+double =double``







### HashMap

1. 同步性
   - `HashMap`是非同步的。这意味着它不是线程安全的，如果多个线程同时访问并修改一个`HashMap`，需要外部同步。
2. 性能
   - 由于非同步，`HashMap`通常比`Hashtable`有更好的性能。
3. Null值
   - `HashMap`允许一个null键和多个null值。
4. 迭代顺序
   - `HashMap`中的元素没有保证的顺序，或者顺序随时间发生变化。
5. 散列和容量
   - `HashMap`提供了调整负载因子和初始容量的选项，以优化存储和性能。

### Hashtable

1. 同步性
   - `Hashtable`是同步的。每个方法都是线程安全的，但这会带来性能开销。
2. 性能
   - 由于其同步性，`Hashtable`在多线程环境中比`HashMap`慢。
3. Null值
   - `Hashtable`不允许键或值为null。
4. 迭代顺序
   - 与`HashMap`类似，`Hashtable`中的元素没有确定的顺序。
5. 遗留类
   - `Hashtable`是Java早期版本的一部分，现在主要出于兼容性原因而存在。

### 使用建议

- 在非多线程环境下，推荐使用`HashMap`，因为它更快。
- 如果需要线程安全的映射，并且可以承受同步带来的性能损失，可以考虑`Hashtable`。但在多数情况下，更好的选择是使用`Collections.synchronizedMap`将`HashMap`包装成线程安全的，或者使用`ConcurrentHashMap`，后者提供了更高的并发性。
- `Hashtable`因为其设计上的限制（如不允许null值）和较老的实现，在新代码中使用较少。



###### ？static

###### ？java堆内存，栈内存，和对应生命周期

###### ？JVM调优

