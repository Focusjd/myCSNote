# JAVA Notes

### String

**Note:** 尽管有string池，但是不能保证编译器的优化，所以**应该使用 .equals()**

String 被声明为 final，因此它不可被继承。

由于字符串（`String`）的不变性（immutability），Java中的字符串行为在某些情况下看起来与基本数据类型（如`int`）相似，尤其是在赋值和参数传递的行为方面。但是，重要的是要理解它们在本质上仍然是不同的：

1. **存储方式**：
   - 基本类型（如`int`）存储的是数据值本身。
   - 引用类型（如`String`）存储的是指向对象内存地址的引用。
2. **不变性与可变性**：
   - 基本类型的值是可变的。你可以改变一个基本类型变量的值，而不会影响其他变量。
   - **`String`是不可变的。任何对字符串的修改都会产生一个新的`String`对象，而不是更改现有对象的内容。**任何看似改变字符串内容的操作(例如拼接)实际上都是创建了一个新的`String`对象，而不是修改原有对象。
3. **参数传递**：
   - 无论是基本类型还是引用类型，Java方法参数的传递都是值传递。对于基本类型，传递的是值的拷贝；对于引用类型，传递的是引用的拷贝。
   - **对于`String`，由于其不变性，即使它是引用类型，方法内对参数的修改（指向新对象）不会影响到原始引用。这种行为在某种程度上与基本类型类似，因为基本类型的值传递也不会影响原始变量。**
4. **性能差异**：
   - 基本类型通常比引用类型更高效，因为它们直接存储值，而不涉及堆内存的分配和垃圾回收。
5. **字符串池**：
   - `String`类型有一个特殊的特性，即字符串池。这是一种优化，使得相同内容的字符串字面量共享同一个实例。这种行为是基本类型没有的。

**因为不可变所以可以有：缓存池，或者string可以用作hashmap的key**



#### Java缓存池

Java的缓存池，通常指的是Java在处理某些类型的数据时，为了提高效率和减少内存使用，而采用的一种机制，这种机制允许重复使用不变的对象。最常见的例子是整数和字符串的缓存池。

1. **字符串常量池（String Pool）**：

   - 当创建字符串时，Java首先检查字符串常量池中是否已存在相同内容的字符串。
   - 如果存在，Java会返回对该字符串的引用，而不是创建一个新对象。
   - 这种方法可以减少内存消耗，并提高性能。
   - 字符串常量池位于Java堆内存中。

2. **整数缓存池（Integer Cache）**：

   **在Java中，`Integer`缓存池的概念仅适用于`Integer`对象，而不适用于基本数据类型`int`。**

   - Java对-128到127之间的整数进行了缓存（这个范围可以通过JVM设置进行调整）。
   - 当创建这个范围内的整数对象时，会从缓存池中获取，而不是每次都创建新的对象。
   - 这样做主要是因为这个范围内的整数使用非常频繁，使用缓存可以提高效率。

3. **除了Float 和Double 之外，其他六个包装器类（Byte、Short、Integer、Long、Character、Boolean）都有常量缓存池**

每次你声明一个新的`int`变量或者给变量赋值，它都会在内存中占用一个新的位置，存储其数值。这是因为`int`是一个基本数据类型，不是对象

### Java的类型提升规则

当表达式中涉及多种不同的数据类型时，**较小的数据类型会被提升到较大的数据类型**，以保持数据的准确性和**避免数据丢失**。例如: ```cha+int+double =double``







### HashMap

1. 同步性
   - `HashMap`是非同步的。这意味着它不是线程安全的，如果多个线程同时访问并修改一个`HashMap`，需要外部同步。
2. 性能
   - 由于非同步，`HashMap`通常比`Hashtable`有更好的性能。
3. Null值
   - `HashMap`允许一个null键和多个null值。
4. 迭代顺序
   - `HashMap`中的元素没有保证的顺序，或者顺序随时间发生变化。
5. 散列和容量
   - `HashMap`提供了调整负载因子和初始容量的选项，以优化存储和性能。

### Hashtable

1. 同步性
   - `Hashtable`是同步的。每个方法都是线程安全的，但这会带来性能开销。
2. 性能
   - 由于其同步性，`Hashtable`在多线程环境中比`HashMap`慢。
3. Null值
   - `Hashtable`不允许键或值为null。
4. 迭代顺序
   - 与`HashMap`类似，`Hashtable`中的元素没有确定的顺序。
5. 遗留类
   - `Hashtable`是Java早期版本的一部分，现在主要出于兼容性原因而存在。

### 使用建议

- 在非多线程环境下，推荐使用`HashMap`，因为它更快。
- 如果需要线程安全的映射，并且可以承受同步带来的性能损失，可以考虑`Hashtable`。但在多数情况下，更好的选择是使用`Collections.synchronizedMap`将`HashMap`包装成线程安全的，或者使用`ConcurrentHashMap`，后者提供了更高的并发性。
- `Hashtable`因为其设计上的限制（如不允许null值）和较老的实现，在新代码中使用较少。



### final

1. 变量：

- **基本数据类型**：变量的值不能改变。
- **引用数据类型**：引用的对象不能改变，但对象本身的状态（它的字段值）可以改变。

2. 方法：

   final 不能被重写

   private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。（`private`方法对其所在类之外是不可见的。这意味着即使子类继承了一个有`private`方法的父类，子类也无法“看到”这个`private`方法。由于子类不能访问、覆盖或以任何方式改变这个`private`方法，因此从实际角度来看，这个方法是final的。）

3. 类：

​	不能被继承





### 类初始化

在Java中，一个类的初始化发生在首次使用时，具体来说，包括以下几种情况：

1. **创建类的实例**： 当首次创建类的实例时，Java虚拟机（JVM）会初始化该类。这包括为类的静态成员变量分配空间并设置初始值，然后执行静态初始化块。
2. **访问类的静态成员**： 当首次访问类的静态成员（变量或方法）时，类将被初始化。这不仅适用于静态变量的读取，也适用于静态方法的调用。
3. **使用类或接口的静态方法**： 当使用类的静态方法时，类将被初始化。
4. **初始化子类**： 如果一个类是另一个类的子类，初始化子类时，会先初始化其父类（除非父类已经被初始化）。
5. **Java虚拟机启动时**： 如果类是一个启动类（即包含 `main` 方法的类），在Java虚拟机启动时，该类会被初始化

### static

存在继承的情况下，初始化顺序为：

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）

静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

**1. 静态变量**

- 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。
- 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

**2. 静态方法**

静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。静态方法只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。

**3. 静态语句块**

静态语句块在类初始化时运行一次。

**执行顺序**： 如果一个类中有多个静态语句块，它们将按照在类中出现的顺序执行。

**4. 静态内部类**

非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。

当 `final` 和 `static` 一起使用时，变量变成了**静态常量**。这意味着它是类级别的（与任何特定实例无关），且一旦被赋值后就不能更改。**且这些字段的访问不会触发类的初始化**





### switch

支持int，Java 7 之后支持String 对象

```java
switch (expression) {
    case value1:
        // 代码块
        break;
    case value2:
        // 代码块
        break;
    ...
    default:
        // 所有其他情况的代码块
}
```



### 多肽Polymorphism

父类引用指向子类对象（类别是父类但行为本身是子类，重写的方法会执行子类，但是只能访问父类有的属性和方法）

```Father a = new Child();```

- **多态**：这是实现多态的一种方式。父类引用可以指向任何一个继承自该父类的子类对象。
- **方法覆盖**：如果**子类重写了父类**的方法，通过父类引用调用该方法时，将**执行子类中的版本**。
- **限制**：虽然父类引用可以指向子类对象，但它**只能访问父类中定义的方法和变量**，不能访问子类中新增的成员。
- **类型转换**：如果需要访问子类特有的成员，可以将父类引用**强制转换**为子类类型（前提是引用确实指向了子类对象）。





### Object通用方法

```java
public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class<?> getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
```

#### equals()

- 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
- 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。



#### hashCode()

hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。

在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。

HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象作为键添加到这些集合类中，需要让对应的类实现 hashCode() 方法。





###### ? HashMap用法

###### ? secroized

###### ？java堆内存，栈内存，和对应生命周期

###### ？JVM调优

###### ? 内部类
