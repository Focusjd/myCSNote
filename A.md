

### SQL执行过程

##### 第一步：客户端发送SQL语句到MySQL服务端

##### 第二步：验证连接合法性（连接器）

##### 第三步：查询缓存，hash

##### 第四步：语法解析和预处理（分析器）

##### 第五步：查询优化（优化器）

##### 第六步：调用存储引擎执行

##### 第七步：将结果返回给客户端



### MySQL索引失效

+ **隐式类型转换** 索引列是字符串类型，而查询条件使用了数值类型，等同于CAST 函数转换string到int
+ **联合索引非最左匹配**
+ **WHERE 中的 OR** 如果or里面有非索引列
+ **模糊匹配**  `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
+ **对索引列使用函数** 如`DATE(column)`）或表达式`column + 1`



### union和union all

union去重 union all保留全部



### char和varchar

`CHAR` 固定长度，删除尾部空格

`VARCHAR` 可变长度，保留尾部空格，占用空间为字符串长度+1



### join

- **内连接**（Inner Join）仅返回两个表中都有匹配的行。
- **左外连接**（Left Join）返回左表的所有行，以及右表中匹配的行；如果右表没有匹配，则显示空值。
- **右外连接**（Right Join）返回右表的所有行，以及左表中匹配的行；如果左表没有匹配，则显示空值



### Java集合

**List**：有序集合，可重复

Set：无序，不可重复 hashset linkedhashset

map：key-value的映射对

queue：linkedlist



### 静态链接 vs 动态链接

### 静态链接库（Static Libraries）

1. **链接方式**：静态库在编译时被包含（链接）到程序中。当你编译一个程序并链接一个静态库时，静态库的内容被复制到最终的可执行文件中。
2. **文件格式**：在 Windows 上，静态库通常有 `.lib` 扩展名，而在 Unix-like 系统（如 Linux 和 macOS）上，它们通常有 `.a` 扩展名。
3. **分发和大小**：由于静态库的代码被复制到每个使用它的可执行文件中，这意味着最终的可执行文件大小会增加。这也意味着一旦程序被编译，就不再需要静态库文件。
4. **性能**：通常，使用静态库的程序启动更快，因为没有额外的加载时间。但程序的总体大小更大。
5. **版本和更新**：静态库的更新比较麻烦，因为每个使用它的程序都需要重新编译。这也可能导致不同的程序使用库的不同版本。

### 动态链接库（Dynamic Libraries）

1. **链接方式**：动态库在程序运行时被加载。编译时，程序知道它将使用的动态库，但直到程序运行时，库才被加载到内存中。
2. **文件格式**：在 Windows 上，动态库通常有 `.dll` 扩展名（Dynamic Link Library），而在 Unix-like 系统上，它们通常是 `.so`（Shared Object）或者 `.dylib`（macOS）文件。
3. **分发和大小**：动态库可以被多个程序共享。这意味着同一个库的单个副本可以被存储在系统上的一个地方，并被多个程序使用，这减少了总体磁盘空间的占用。
4. **性能**：虽然动态库可能会导致程序启动时略微延迟（因为需要加载库），但它们降低了程序的总体大小。
5. **版本和更新**：更新动态库更加容易，因为只需替换系统中的单个库文件。所有使用该库的程序都将使用新的版本，前提是接口兼容。

### 总结

- **静态库**：适用于需要快速运行且不介意大文件大小的应用；难以维护。
- **动态库**：减少总体占用空间；易于更新和维护；但可能有轻微的性能开销。
